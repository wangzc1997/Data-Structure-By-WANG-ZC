/*
二叉树 BinaryTree
1.二叉树的深度小于等于结点树N，可证明平均深度是O(根号N)。
2.斜二叉树，也称为退化二叉树，深度达到最大N，已经退化成线性表
3.完美二叉树/满二叉树，所有分支结点都存在左子树和右子树，并且所有叶结点都在同一层上。
4.完全二叉树：对于一颗深度为K，有n个结点的二叉树，对树中所有结点按从上至下，从左至右的顺序进行编号，如果编号为i的结点与满二叉树中编号为i
的结点在二叉树上的位置相同，则称为完全二叉树。 完全二叉树的特点：叶结点只能出现在最下层和次下层，且最下层的叶结点集中在树的左部。
完全二叉树是最理想的树结构，深度是LogN.
*/

/*
二叉树的存储：
二叉树的存储不仅需要存储各个结点的数据，还要存储结点之间的逻辑关系（父子关系）.
*/

/*
二叉树的顺序存储结构：
用一组连续的存储单元(数组)存储二叉树的结点数据，结点的父子关系是通过它们的相对位置来反映的，而不需要任何附加的存储单元来存放指针。
通常情况下顺序存储结构用于完全二叉树的存储。

具体实现是从树的根结点开始，从上层至下层，每层从左到右，依次给结点编号并将数据存放到一个数组的对应单元中。
总的来说，在N个结点的完全二叉树中，对于下标为i的结点：
1.当i/2向下取整 大于等于1时，i/2向下取整的单元是其父结点；当i/2向下取整等于0时，则代表该结点是树的根结点，无父结点。
2.当2i<=N时，2i单元是其左孩子，否则无左孩子。
3.当2i+1<= N时，2i+1是其右孩子，否则无右孩子。
！！！上述计算方式，确定父子关系所用的数组起始单元下标是1，而不是0.
*/


/*
二叉树的链表存储
虽然完全二叉树的顺序存储具有存储空间利用率高，计算简单的双重优点，但它并不适用于一般的二叉树。
对于一般的二叉树而言，如果要使用顺序存储结构，还需要增加“虚”结点，堆成完全二叉树，才可以使用顺序存储。但是会大大浪费存储空间。
另外二叉树的顺序存储还有不易实现增加、删除操作的缺点。

实际上，二叉树的最常用表示方法是用链表表示，每个结点由 数据 和 左右指针 三个数据成员组成。
下面是二叉树的链表结构
*/
typedef struct TNode *position;
typedef position BinTree;
struct TNode
{
    //树结点定义
    elementtype Data;
    BinTree left;
    BinTree right;
};

//二叉树的操作
/*
二叉树的遍历
树的遍历是指访问树的每一个结点，且每个结点仅被访问一次。
二叉树的遍历可按二叉树的构成以及访问结点的顺序分为四种方式，即先序遍历、中序遍历、后序遍历和层序遍历。
L代表左分支，V代表访问结点，L代表右分支。那么有6种不同的访问顺序，因为规定对某一结点的左子树的遍历总是在右子树之前，
则剩下三种次序的遍历 LVR LRV VLR。按照V的位置，依次是中序遍历，后序遍历和先序遍历。
*/

/*中序遍历：
1.中序遍历其左子树
2.访问根结点
3.中序遍历其右子树。
这个过程用递归的话很方便。

*/
void InorderTraversal(BinTree BT)
{
    if (BT)
    {
        InorderTraversal(BT->left);
        //此处假设对BT结点的访问就是打印数据
        printf("%d",BT->Data); //假设数据为整型
        InorderTraversal(BT->right);
    }
}
/*
若是用非递归的思想来做，则遍历实际上是：
从树根结点开始，沿其左孩子域向下移动，直到某一结点再无左孩子为止，访问这个最左边的结点，接下来再从结点的右孩子结点开始进行中序遍历，
当右子树遍历完了以后，退回到上一层的未访问结点继续二叉树的遍历，直到树中所有结点被访问为止。

因为是从下面向上面逐层递进，所以我们要使用堆栈来直接实现相应的非递归算法，在按中序遍历二叉树时，遇到一个结点，就把它压栈，并去遍历其左子树；
当左子树遍历结束后，就从栈顶弹出这个结点，然后按照其右指针再去中序遍历该结点的右子树。
下面是非递归算法的代码
*/
void InorderTraversal(BinTree BT)
{
    BinTree T;
    Stack S = CreatStack(); //创建堆栈S，元素类型是Bintree。
    T = BT; //从根结点出发
    while (T || !isempty(S)) //当T非空，而且S是空的时候
    {
        while (t)
        {
            Push(S,T);
            T = T->left;
        }
        T = Pop(S); //上面左子树遍历完了，现在把结点弹出堆栈
        printf("%d", T->Data); //访问/打印结点
        T = T->right;        
    }
}

/*
层序遍历，除了先序、中序和后序遍历三种基本的 二叉树 遍历方法外，有时还用到二叉树的层序遍历。

二叉树的层序遍历是

*/