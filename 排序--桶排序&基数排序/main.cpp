/*
桶排序：以学生分数为例，0-100分，写成数组有101个数组单元，每个单元都有自己的分值，分别是0,1,...,100。然后每个数组单元都指向一个链表，如果有学生考到了某个分数，
则在该数组单元的链表下插入。

下面是桶排序的伪代码
*/
void Bucket_Sort(elementtype A[], int N)
{
    count[]初始化;
    while (读入一个学生成绩grade)
    {
        将该生插入count[grade]链表;
    }
    for (i =0; i < M; i++)
    {
        if (count[i])
        {
            输出整个count[i]链表;
        }
        
    }
    
    
}

/*
时间复杂度T(N,M) = O(N + M),M 代表 桶的个数， N个学生成绩。

但是如果M >> N， 显然桶排序是不合适的，因为大部分的桶都是空着的。

*/


/*
基数排序
如果我们有N = 10个整数，但是每个整数的范围是0-999,即M = 1000，如何操作才能保持有线性时间内排序

按照次位优先的排序方法来做，
1.先按照个位数0-9进行排序，把数据放好位置。保持好顺序(很重要)
2.再根据十位数进行排序，保持好顺序
3.最后根据百位数进行排序，
4.最后结果，总共0-9，10个桶，每个桶下面的都是排好序的数据。

基数排序是稳定的排序方法。
*/



/*
汇总一下各种排序方法的稳定性：

稳定的有：冒泡排序、直接插入排序、归并排序、基数排序

不稳定的：简单选择排序、希尔排序、堆排序、快速排序。


*/