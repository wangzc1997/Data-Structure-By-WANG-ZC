/*
队列是先进先出，先来先服务，队列中的元素没有哪个是有特权的，前面的元素未处理完，后面的只能等待。
但是有些情况，许多情况需要有特权，比如"小作业优先"的排队策略。
而堆Heap正是考虑了适合于特权需求的数据结构，因此，堆也通常被成为 优先队列(Priority Queue)

堆的定义和表示：堆是特殊的队列，从堆中取出元素是依照元素的优先级大小，而不是元素进入队列的先后顺序。

为什么要引入堆来做有优先队列？事实上我们也可以使用简单地线性数组或者链表来实现有N个元素的优先队列：
1.如果使用数组，插入时可以将新元素放在末尾，时间复杂度是O(1)，但是要删除优先级最高的元素，要从头到尾进行遍历，并且删除时还涉及到其他元素的位置移动
问题，时间复杂度是O(N).
2.如果使用链表，新元素可插入在链头处，时间复杂度是O(1),但删除元素也一样需要遍历全部元素，虽然找到后删除用时O(1)，但是总的时间代价仍然是O(N).
3.如果使用有序数组，可令元素按优先级从低到高排列，这样删除的时候，只要删除最后一个元素即可，复杂度变成O(1)，但是插入就变得很麻烦，因为要
保证插入后元素仍然是有序的，需要用O(logN)的时间来找到合适的插入位置，而且在数组中插入元素时涉及到其他元素的位置移动问题，最坏情况下， 时间复杂度仍然是
O(N).
4.若链表中数据要求有序的话，删除元素代价为O(1),而插入变为O(N).

但上述4种方法，最坏情况下它们的时间复杂度都会达到O(N),而我们知道，二叉搜索树的插入和删除操作代价都O(logN)，所以我们可以考虑使用树型结构达到
这种性能。

堆的最常用结构是用二叉树表示，不特指的话，是一棵完全二叉树。因此，通常不必用指针，而是用数组来实现堆的存储。！！！要注意的是：所用的数组起始单元
为1，而不是通常的从0开始表示。这样做的目的是很容易从子结点找到其父结点，即对于下标为i的结点，其父结点的下标为i/2向下取整。反过来，找结点i的左右子结点
也很简单，分别是2i和2i+1.

用数组表示完全二叉树是堆的第一个特性，叫做堆的结构特性。堆的另一特性是其部分有序性，即指任一结点元素的数组与其子结点所存储的值是相关的。
相关性的不同决定了两种不同的基本堆：最小堆MinHeap和最大堆MaxHeap。

在最大堆MaxHeap中，任一结点的值大于或等于其子结点的值。这一性质决定了根结点元素的值在整个堆中是最大的。
在最小值MinHeap中，任一结点的值小于或等于其子结点的值，那么根结点元素的值在整个堆中是最小的。

在堆中兄弟结点之间并不存在什么约束，可能出现根的左子树各结点的值都大于右子树所有结点的值的情况。

很明显，需要小键值优先时，可以使用最小堆；反之，当大键值优先时，则要使用最大堆。
下面以最大堆为例
*/

/*
最大堆MaxHeap
一个有N>0个元素的最大堆H是一棵完全二叉树，每个结点上的元素值不小于其子结点元素的值。
重点关注下列操作：
MaxHeap CreatHeap(int Maxsize); //创建空的最大堆，其最大长度为Maxsize
bool IsFull(MaxHeap H); //判断最大值H是否已满，若是则返回true，否则返回false；
bool Insert(MaxHeap H, elementtype X); //将元素X插入最大堆H，若堆已满，返回false,否则将数据元素X插入到堆H并返回true。
bool IsEmpty(MaxHeap H); //判断最大堆H是否为空，若是则返回true，否则返回false.
elementtype DeleteMax(MaxHeap H); //删除并返回H中最大元素
*/

/*
堆结构
*/
typedef struct HNode * Heap; //堆的类型定义
struct HNode{
    elementtype *Data; //存储元素的数组
    int size;  //堆中当前元素个数
    int Capacity; //堆的最大容量
};
typedef Heap MaxHeap;
typedef Heap MinHeap;
/*
注意在根据用户输入的Maxsize建立空的最大堆时，数组应该有Maxsize+1个元素，因为数组起始单元为1，元素是存在第1~Maxsize个单元中，通常第0个元素
是无用的，但是如果我们事先知道堆中所有元素的取值范围，也可以给第0单元赋一个特殊的值MAXDATA，比堆中任何一个数据元素都要大，起到哨兵作用(插入时用到)

下面是最大堆的创建
*/
#define MAXDATA 1000;
MaxHeap CreatHeap(int Maxsize);
{
    //创建容量为Maxsize的空的最大堆
    MaxHeap = (MaxHeap)malloc(sizeof(struct HNode));
    H->Data = (elementtype *)malloc((Maxsize + 1)*sizeof(elementtype));
    H ->size = 0;
    H->Capacity = Maxsize;
    H->Data[0] = MAXDATA; //哨兵  

    retuen H;
}

/*
下面是最大堆的插入。
最大堆的插入有点复杂。需要看插入数值的大小来定：
假设此时最大堆有三层，要在第三层插入一个树
1.若插入数值小于其父结点，即第二层的那个数，则直接插入即可。
2.若插入数值大于其父结点(第二层),小于其父结点的父结点(此例为根结点)，那么插入数值与其父结点互换位置。
3.若插入数值大于根结点，则插入数值直接放在根结点上，前根结点和本应该的父结点下移(因为要保证堆元素之间的部分有序性)

简而言之，完成一个元素的最大堆插入操作，只要从完全二叉树的新增结点开始，顺着其父结点到根结点的路径，将路径上的各点依次与新元素值进行比较，
当一结点的值小于新元素的值，就下移这个结点的元素，知道有结点的值大于新元素的值 或者 根结点 都下移为止，那么空出来的位置就是新元素插入点。

再简而言之，从新增的最后一个结点的父结点开始，用要插入的元素 向下 过滤 上层结点。

上述插入数值的情况3，如果新插入的X比原来堆中的所有元素都要大，那么它将一直向上比较到根结点都不会停止。这时，哨兵MAXDATA就起作用了，
当i为1时，就不满足H->Data[i/2] < X条件了，就可以自然跳出循环了。
*/

//最大堆的插入算法  //插入之前应检查堆是否已满。
bool IsFull(MaxHeap H)
{
    return (H -> size == H ->Capacity);
}

bool Insert(MaxHeap H, elementtype X)
{
    //此时H->Data[0]已经被定义为哨兵
    int i;

    if (IsFull(H))
    {
        printf("最大堆已满");
        return false;
    }else
    i = ++H->size; //i指向 插入后 堆中最后一个元素的位置 
    for ( ; H->Data[i/2] < X; i/=2)
    {
        H->Data[i] = H->Data[i/2];//上滤X
    }
    H->Data[i] = X; //跳出循环后就已经找到了X的位置了。
    return true;
}

/*
最大堆的删除。
首先要搞清楚最大堆的删除意味着什么？
1.取出最大值，即根结点的元素。
2.同时要删除堆的一个结点。因为什么？是因为我根结点只是把元素删掉了一个，根结点还空着，而我删掉了一个元素，不能还保持之前的结构，所以必须要删除
一个结点，然后动态调整整个堆，把根结点给补齐，把删除结点的元素放到自己应该在的位置。而因为最大堆要保持完全二叉树的结构，所以我们只能删除最后
一个结点。最后一个结点的数据元素应该放在哪是一个关键的问题。 (简单，就是我有一个空结点，我必须要从下面找一个数放进去，为了完全二叉树的结构，我需要
把最后一个结点位置的元素给补齐到上面)
*/

/*
思路：将删除结点(数组中的最后一个元素单元)的元素作为假设的根结点，依次与其下层的子结点进行比较，如果小于子结点的元素值，则从两个子结点中选择
值大的元素上移一层，直到在其某一点上(直到最后),比较结果是大于两个子结点的值，此时的空结点就是要放置删除结点元素的正确位置。

一句话的简单概括：
从根结点开始，用最大堆中的最后一个元素 向上 过滤 下层结点。 意思是 从上向下，依次过滤下层结点，通过的结点则向上移动。
*/
#define ERROR -1 //错误标识应根据具体情况定义为堆中不可能出现的元素值

bool IsEmpty(MaxHeap H)
{
    return (MaxHeap->size == 0);
}

elementtype DeleteMax(MaxHeap H)
{
    int Parent, Child;
    elementtype MaxItem, X;
    if (IsEmpty(H))
    {
        printf("最大堆已空");
        return ERROR;
    }

    MaxItem = H->Data[1]; //取出根结点存放的最大值
    //用最大堆的最后一个元素从根结点向上过滤下层结点
    X = H->Data[H->size--]; //因为总体数组规模要减小
    for (Parent = 1; Parent * 2 <= H ->size; Parent = Child)
    {
        Child = Parent * 2;
        if ((Child!=H->size)&&(H->Data[Child] < H->Data[Child + 1]))
        {
            Child ++ ; //Child指向做左右子结点的较大者
        }
        if (X >= H->Data[Child])
        {
            break; //找到了合适的位置，不要再往下过滤了
        }else //没找到，则继续下滤X
        {
            H->Data[Parent] = H->Data[Child]; //把下面的移到上面
        }
    }
    H->Data[Parent] = X;

    return MaxItem;
}

/*
最大堆的建立
一种耗时比较长的操作：通过最大堆的插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，时间代价最大为O(NlogN)

一个更简便的方式：
1.将N个元素按输入顺序存入二叉树中，只要求满足完全二叉树的结构特性，不用管其有序性
2.调整各结点元素，以满足最大堆的有序特性。

主要的是第二个。从第N/2向下取整的这个结点开始(为什么要从这个开始？因为这个是最后一个结点的父结点)，对包括此结点和前面的那些结点，逐一进行向下过滤操作(就是每个结点与它的子树中子孙结点进行比较过滤)

下面是上述建立最大堆的过程函数
*/
void PercDown(MaxHeap H, int p)  //这个是向下过滤的函数
{
    int Parent, Child;
    elementtype X;

    X = H->Data[p]; //取出根结点存放的值
    for (Parent = p; Parent * 2<= H->size; Parent = Child)
    {
        Child = Parent * 2;
        if ((Child != H->size)&&(H->Data[Child] < H->Data[Child + 1]))
        {
            Child++; //Child指向左右子结点的较大者
        }
        if (X > H->Data[Child])
        {
            break;
        }else
        {
            H->Data[Parent] = H->Data[Child];
        }
    }
    H->Data[Parent] = X;
}

void BuildHeap(MaxHeap H) //建立最大堆的过程
{
    //这里假设所有H->size个元素已经存在H->Data[]中
    int i;

    //从最后一个结点的父结点开始，到根结点1
    for (i = H->size/2; i>0; i--)
    {
        PercDown(H,i);
    }
}
//这样建立的最大堆 时间复杂度与结点个数呈线性关系
