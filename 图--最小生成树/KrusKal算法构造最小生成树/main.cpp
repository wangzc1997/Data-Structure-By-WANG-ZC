/*
Kruskal算法是一种按照网图中边的权值递增的顺序构造最小生成树的方法，其基本思想就是初始时，最小生成树T由图中全部|V|个顶点构成，顶点之间没有一条边，这样T中各顶点各自
构成仅有一个顶点的连通分量。 然后按照边的权值由小到大的顺序，按照贪心原则考察G的边集E中的各条边。

这里的贪心原则，就是我们每次选取权值最小的边作为T的候选边。但是也要有一个条件，如果两个顶点属于同一个连通分量，那么在它们之间加一条边一定会构成回路。
所以，如果候选边的两个顶点属于T的两个不同的连通分量，则此边可以作为最小生成树的边添加到T中，否则舍去此边，以免构成回路。

可见，与Prim算法从根结点长出一棵树的过程不同，Kruskal方法是把初始仅包含|V|个孤立顶点的森林逐步合成一棵生成树的过程。

综上所述，实现Kruskal算法的核心工作有三点：
1.选取一条权重最小的边，因为权重是不变的，所以所有边可以事先按照权值升序排列，时间复杂性是O(|E|log|E|).如果不能把所有边事先排序，也可采用优先队列(最小堆)结构。
总的时间复杂性还是O(|E|log|E|)。
2.判定一条边的两端是否属于同一棵树，这项工作可以用并查集的运算Find的返回值是否相同来检验，需要一个辅助的数组parents[]记录每个顶点的父顶点。
3.合并两棵树，使用并查集的合并运算Union来实现。

下面是kruskal函数伪代码
*/
int Kruskal(LGraph Graph, LGraph MST)
{
    //将最小生成树保存为邻接表存储的图MST，返回最小权重和
    MST = 包含全部顶点但没有边的图 //参考图的遍历那个地方
    while (MST中收集的边不到Graph->NV-1条 && 原图的边集E非空)
    {
        从E中删除最小代价边(V,W);
        从E中删除此边(V,W);

        if ((V,W)的选取不在MST中构成回路)  //此判断由并查集的Find完成
        {
            将(V,W)加入MST；
        }else
        {
            彻底丢弃(V,W);
        }
    }
    if (MST中收集的边不到Graph->NV-1条)
    {
        return ERROR;
    }else
    {
        return 最小权值和;
    }
    
    
}
//总时间复杂度为O(|E|log|V|).当图比较稀疏时，用Kruskal算法比Prim算法的效率更高。