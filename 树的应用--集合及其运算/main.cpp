/*
集合是一种常用的数据表示法，集合运算包括交、并、补、差以及判定一个数据是否是某一集合的元素等。

为了有效地对集合执行各种操作，可以用树的结构表示集合，树的每一个结点都代表是一个集合的元素。例子见P159
可以把集合的元素表示成多叉树，每个结点允许有多个子结点。并且这里的结点指针不是从父结点指向子结点，而是由子结点指向父结点。
每个根结点与其集合名称相关联(就是//集合名称放在一个数组里面//，比如第一个集合，用多叉树表示，这个多叉树的根结点再有一个指针指向数组的第一个单元)，而且
选哪个结点作为代表表示此集合的父结点是无关紧要的。采用这样的树结构表示集合的好处是有利于判定某个元素所属的集合，也便于集合的归并运算。

但是从另一方面考虑， 在执行集合运算时，关注的是集合中的元素，并不在乎集合名的结构(/就是上文的集合名称放在一个数组里面，这个数组其实没必要存在/)
我们要用一个数组把这些数据，分成不同的集合，虽然表示方法可以用多叉树，但是我们也要改进一下集合的存储形式

下面就是集合的数组存储：
1.我们把N个元素从0~N-1进行编号，当把它们存储到数组中时，它们的下标范围也是从0到N-1。
2.在集合表示成的多个多叉树中，我们把根结点的父结点值定为-1.
3.对于非根结点，自然这些结点的父结点值就是其根结点的编号(下标)。

这样操作后，数组内的值就是其所有结点的父结点的值，数组的下标就是对N个元素进行的编号。

下面，我们把N个集合元素的类型elementtype 定义为int，即简单的用0~N-1的编号来代替实际元素，于是集合的类型可描述为
*/
#define MAXN 1000 //集合最大元素个数
typedef int elementtype; //默认元素可以用非负整数表示
typedef int SetName; //默认用根结点的下标作为集合名称
typedef elementtype SetType[MAXN];  //假设集合元素下标从0开始


/*
集合运算

1.查找某个元素所在的集合
查找编号为X的元素所属的集合，可以沿着该元素父结点指针向上查，当发现一个元素的指针域值为负数时，该元素就是X所属集合的树根结点。
下面是实现代码find函数
*/
SetName Find(SetType S, elementtype X)
{
    for ( ; S[X] >= 0; X = S[X]);
    return X; //当S[X]小于0时，就找到了其树根结点，即确定了所在的集合
    
}

/*
2.集合的并运算
集合并运算就是要完成将元素X1和X2所属的两个集合合并的操作。
1.首先找到两个元素所在集合树的根结点
2.如果两个根结点不同根，则将其中一个根结点直接作为另一个根结点的孩子就行了，直接将其中一个根结点的父结点域值设置成另一个根结点的数组编号(下标)即可。

下面的代码为实现集合并运算的Union函数，这里默认传入函数的Root1和Root2是两个不同集合的根结点。
所以在使用这个Union函数前，我们要先判断一下是不是符合条件。我们可以通过调用Find(X1)和Find(X2),得到两个集合的根结点，然后比较一下，如果不同
则可以用这个Union函数，进行合并集合。否则根本没必要合并，因为他们本来就在一个集合内
*/
void Union(SetType S, SetName Root1, SetName Root2)
{
    //默认不是同集合
    S[Root2] = Root1;
}

/*
3.按秩合并 
上面的并运算有一个缺点，假设有N个独立的元素，一开始各自独立，然后要执行一系列的并运算的话
1.合并1和0所在的集合，S[0] = 1,生成根为1，高度为2的树
2.合并2和0所在的集合，则Find(S,0)要经历搜索两个结点找到根结点1，然后调用Union函数，S[1] = 2,生成根为2，高度为3的树
3.合并3和0所在的集合，Find要经历搜索三个结点，然后····

这样依次下来，生成的集合树越来越高，最后生成一个线性表。当然总执行时间会越来越长变成O(N^2),因为每次总是把一个高树并到了一棵矮树上。

如果我们每次合并前先比较一下树的高度，把矮树并到高树上，就不会改变结果树的高度，不会出现上面的线性表类的树
当然，要做到这一点，我们需要快速知道每个集合的树有多高，但这并不容易做到，比较容易获得的是集合的规模，就是集合中元素的个数。用规模代替高度，也可以起到
比较好的作用。如果每次都把规模小的树并到大树上，那么在P162的例子中(合并成了线性表的那个)，整套操作的时间复杂度就降为O(N)了。这种按规模或者按高度
进行合并的算法，就统称为按秩合并。

为了实现上面这个思路，能够快速获得集合的规模，我们把对应集合的树的总结点数存在根结点单元里。同时为了与普通结点区分开，我们在这个数字前加负号，
使之仍然为负数。即如果S[Root2] < S[Root1]，则说明Root2的规模要大于Root1的规模！！！
当合并这两个集合时，新的根结点应该存两个集合规模之和
*/
void Union(SetType S, SetName Root1, SetName Root2)
{
    if (S[Root2] < S[Root1])
    {
        S[Root2] += S[Root1]; //因为Root2的规模大，且要把小树合并到大树上，所以需要S[Root2] += S[Root1];
        S[Root1] = Root2; //更新一下root1集合的父结点编号
    }else
    {
        S[Root1] += S[Root2]; 
        S[Root2] = Root1; 
    }
}


/*
路径压缩，很有意思

如果一棵集合树不幸的长高了，而我们又不得不反复调用Find去查找它最底部的某个元素，怎么做能提高效率？

递归地把X的父结点的值S[X]设置为对其当前父结点S[X]执行Find函数的结果，并且返回更新后的父结点值；直到X本身是集合的根，被Find返回给上一层。

执行效果是：每返回一层，Find就把当前结点的父结点设置成根结点， 即把当前元素直接变成根结点的孩子，并且一路返回根结点的值。
最后从X到根结点的路径上所有的结点都变成了根结点的孩子，这就是路径的压缩
*/
SetName Find(SetType S, elementtype X)
{
    if (S[X] < 0)
    {
        return X;
    }else
    {
        return S[X] = Find(S,S[X]);  //S[X]就是X的父结点所在的位置
    }
    
    
}