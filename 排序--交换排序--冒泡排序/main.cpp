/*
冒泡排序是最简单的交换排序，对元素个数为N的待排序序列进行排序时，共进行N-1次循环。在第k次循环中，对从第1到第N-k个元素从前往后进行比较，每次比较相邻的两个元素，
若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变。这样一次循环下来，就把第k大的元素移动到第N-k个位置上，称为第k趟的冒泡。整个过程一共进行N-1趟冒泡，
直到第1个和第2个元素比较完成，最终剩余最小的元素，留在第一个位置上，排序结束。

令k=1，则第一趟的冒泡：第一次循环中，对从第1到第N-1个元素，从前往后进行比较，每次比较相邻的元素，这样一次循环下来，就把第1大(也就是最大的)元素挪到了第N-1个位置上，循环
结束后，这个最大的元素就在第N个位置上，它将不再参与接下来的冒泡。也就是说，我第一次就把最大的元素给传递到最后一个位置上了。第二趟冒泡后，剩余N-1个记录中最大的记录移动到
了第N-1个位置上。                                                                                                                                           

下面的冒泡程序的算法实现，添加了一个flag标记，检查一趟扫描有没有元素需要交换，如果没有任何元素交换，说明序列已经全部有序，，不需要继续执行下一趟扫描，可直接结束。
在序列基本有序的情况下，增加一个flag虽然在每次交换时增加了一次赋值操作，但可以避免大量冗余的扫描，总体还是合算的。

加个flag的话，比如说第一次循环的时候，我比较的是从1~N-1个数据，如果循环结束后，flag没有发生变化，则说明从1到N-1个数据都是有序的，并不需要for循环，继续遍历从1~N-2了。
*/
void BubbleSort(elementtype A[], int N)
{
    int P, i;
    bool flag;

    for (P = N-1; P >= 0; P--)
    {
        flag = false; //标记该次循环中是否发生交换，若无，则说明整个序列有序
        for (i = 0; i < P; i++)
        {
            if (A[i] > A[i+1])
            {
                Swap(A[i],A[i+1]);
                flag = true; //标识发生了交换
            }
            
        }
        if (flag == false)
        {
            break;
        }
        
        
    }
    
}
/*
显而易见，冒泡排序最坏的情况下，就是序列是逆序排列的，每一次比较都要进行一次交换，时间复杂度为O(N^2)，最好的情况下，序列已经是排好序的，这是由于应用了
flag标记只要进行O(N)次比较就可以从循环中跳出来了，完成排序。

总的来说，程序的平均时间复杂度为O(N^2).空间复杂度方面，冒泡排序只需要常数个额外空间用于保存中间变量。 此外，冒泡排序是稳定的，关键字相等的两个记录相对顺序不会因为
比较而改变，即相对位置不会改变。

*/