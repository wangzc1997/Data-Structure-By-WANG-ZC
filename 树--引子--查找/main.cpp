/*
查找的严格定义为：给定一个记录的集合R，根据某个给定的关键字K，从集合R中找出关键字与K相同的记录，返回该记录的信息或该记录在集合中的位置，
若集合中存在这样的记录，则称查找是成功的。反之则是不成功的，返回一个空记录或空指针。

查找分为：静态查找和动态查找两类。

静态查找：指集合中的记录是固定的，不涉及对记录的插入和删除操作，而仅仅是按关键字查找记录。静态查找的效率主要用“平均查找长度”来
衡量，平均查找长度就是查找总次数乘以查找到该记录的概率。一个好的查找算法应能使得平均查找长度最小化。

静态查找通常是从一个线性表中查找数据元素，而线性表有顺序存储结构和线性链表存储。下面是两种静态查找方法
*/

//1.顺序查找：最基本直接的查找方法，从线性表的一端开始，向另一端逐个取出数据元素的关键字，并与要找的关键字K进行比较，以判定是否存在要找的
//数据元素。

/*
下面这个很关键！解释了“哨兵”的作用
以数组存储为例，设数据元素从下表为1的数组单元到下标为Last的单元存放。
下面为了简化算法（减少内存降低时间）采用从后向前找，但为了使得不必判断表是否检查完毕，可以在检查开始前，作为哨兵 将 “要查找的关键字K” 存入
下标为0的数组单元（注意这个下标为0的数组单元就是一个哨兵），这样，即使原表1~Last单元中没有关键字为K的记录，算法再多一次查找下标为0的单元，
也会找到元素而终止（意思就是不用在设个条件来描述，如果没有找到的话，怎么办），而此时用返回数组下标值0表明查找失败。

下面是顺序查找sequential的代码
*/
position sequentialSearch(List Tb1, elementtype K) //这里面的i和position的结构，在线性表--顺序存储结构里面
{
    //使用哨兵
    position i;

    Tb1 -> Data[0] = K;
    for (i = Tb1 -> Last; Tb1->Data[i]!=K ; i--);
    return i;
}
/*顺序查找的平均查找次数是n-i+1，然后乘以对应概率并相加； 如果是每个数据元素是等概率的，那么总共的平均查找次数就是(n+1)/2,
查找不成功时，则直到哨兵为止，总共进行n+1次比较，由此可见，顺序查找的时间复杂度为O(n)
*/

/*
下面是二分查找BinarySearch，是针对线性表中数据的存放是有序的这一特殊性，而采用的一种有效方法。利用有序的特性来缩小查找的范围，使得接下来的查找
总是在上一次查找范围的一个子集中进行。

对于二分查找，我们还要对数据进行标序号
*/

#define NotFound 0 //找不到则返回0
position BinarySearch(List Tb1, elementtype K)
{
    //在顺序存储表里面查找K

    left = 1;
    right = Tb1 -> Last;
    while (left <= right)
    {
        mid = (left + right) /2;
        if (K < Tb1 -> Data[mid])
        {
            right = mid - 1;
        }else if (K > Tb1 -> Data[mid])
        {
            left = mid +1;
        }else
        {
            return mid;
        }
    }
    return NotFound; 
}
/*
在二分查找中，我们不需要通过在0单元设置哨兵来判断是否查找成功，而是通过判断是否还有合理的剩余查找范围。
在上面的程序中，我们的合理查找范围是1-last，然后notfound设置为0；我们其实也可以从0开始查找，notfound设置为-1。

算法复杂度：当没有K这个元素的时候，算法复杂度达到最大。设经过K步，查找范围从n减小到1，因为每次查找范围是上一次的1/2，所以可以
得到关系式 n/2^k = 1，那么K = log2（n）,可以得到结论，二分查找算法具有对数的时间复杂度o(logn)。


*/