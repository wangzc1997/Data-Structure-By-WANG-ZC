/*
----排序----
不同的排序方法，效率会相差很多，而效率其实跟数据的特点直接或间接相关的。 
需要特别指出的是：没有一种排序算法在任何情况下都是最优的，我们必须学会根据实际情况选择最优的算法来解决问题。

排序算法的稳定性：在一组待排序列记录中，如果存在任意两个相等的记录R和S，且在待排序列中R在S前，如果在排序后R依然在S前，即它们的前后位置在排序前后不发生改变，则称该
排序算法为稳定的。
*/


/*
选择排序
 
1.简单选择排序
Simple Selection Sort. 是一种直观的排序算法，其思想是在未排序的序列中，选出最小的元素和序列的首位元素交换，接下来在剩下的未排序列中最小元素与序列的第二位元素交换，
依次类推，最后形成从小到大的已排序序列。 ”就是不断的找出最小的从前往后放“

下面是简单选择排序的C语言实现
*/
void Swap(elementtype *a, elementtype *b)
{
    elementtype t = *a;
    *a = *b;
    *b = t;
}

void SimpleSelectionSort(elementtype A[], int N)
{
    int i,j,min;

    for (i = 0; i < N-1; i++)
    {
        min = i;
        for (j = i+1; j < N; j++)
        {
            if (A[j] < A[min])
            {
                min = j;
            }
            Swap(&A[i], &A[min]);
            
        }
        
    }
    
}
/*
可以看出，简单选择排序无论在什么情况下， 都需要比较N*(N-1)/2次，故其时间复杂度为O(N^2).事实上，在将第i个元素与最小元素交换之前，我们可以判断一下，如果min==i，
则不用交换，那么简单选择排序移动元素的次数在最好的情况下是0次(此时是最理想的情况，都是有序的)，在最坏的情况下，为3(N-1)次，除了最后一个元素外，每个元素都要经过3步交换位置。
*/