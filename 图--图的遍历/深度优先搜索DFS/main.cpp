/*
深度优先搜索，Depth Search First, DFS. 是树的先序遍历的推广。假设初始状态是图中所有顶点未曾被访问，则深度优先搜索可从图中某个顶点v0出发，
访问此顶点，然后依次从v0的未被访问的邻接点出发递归地进行同样的深度优先搜索，直至图中所有与v0有 路径相通 的顶点都被访问到(注意是与v0路径相通，而
非与v0直接相邻)，重复上述过程，直至图中所有顶点都被访问到为止。

意思就是 选取一个顶点，不断递归访问相通的结点。若完成后还有未被访问的顶点，则换一个顶点继续。

因为这是一个递归的过程，为了在遍历过程中便于区分顶点是否已经被访问，所以需附设访问标志 数组Visited[],这个数组时全局变量，其NV个分量初值都是false，
一旦某个顶点被访问，则其相应的分量置为true。

下面是实现上述深度优先遍历DFS递归算法的伪码描述
*/
/*假设Visited[]为全局变量，已经初始化为false*/
void DFS(Graph G, Vertex V, void(*Visit)(Vertex))
{
    //从第V个顶点出发递归地深度优先遍历图G
    Visit(V);
    Visited[V] = true;
    for (V的每一个邻接点W)
    {
        if (!Visited[W])
        {
            DFS[G, W, Visit];
        }
        
    }
    
}
/*
其中Visit(V)是访问顶点V的函数调用，它可以根据不同的应用改变。算法DFS是对抽象数据结构“图”的一个连通分量进行遍历的操作，与选择的存储图的具体数据
结构无关。

更具体地，如果选择邻接表作为图的数据结构，则用打印顶点编号作为访问函数Visit(V)的任务，对一个连通分量的DFS遍历代码如下：
*/
void Visit(Vertex V)
{
    printf("正在访问结点%d", V);
}

/*Visited[]为全局变量，已经初始化为false*/
void DFS(LGraph Graph, Vertex V, void(*Visit)(Vertex))
{
    PtrToAdjVNode W;

    Visit(V);
    Visited[V] = true;

    for (W = Graph->G[V].FirstEdge; W; W= W->Next) //对V的每个邻接点W->AdjV
    {
        if (!Visited[W->AdjV])
        {
            DFS(Graph, W->AdjV, Visit);
        }
        
    }
    
}
/*
在遍历时，对图中每个顶点至多调用一次DFS函数，因为一旦某个顶点被标志成已被访问，就不再从它出发进行搜索，因此，遍历图的过程实质上
是对每个顶点查找其邻接点的过程。其耗费的时间则取决于所采用的的存储结构，当邻接矩阵作为图的存储结构时，查找所有顶点的邻接点所需时间
为O(|V|^2)。而当以邻接表作为图的存储结构时，找邻接点所需时间为O(|E|).因此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为
O(|E|+|V|);
*/