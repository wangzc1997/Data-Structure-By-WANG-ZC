/*
广度优先搜索Breadth First Search, BFS.类似于树的按层次遍历的过程。 六度空间理论就是BFS的一个富有成效的应用。

假设从图中某顶点v0出发，在访问了v0之后依次访问v0的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问他们的邻接点。
而且要使得“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。
如果此时图中还有顶点没有被访问到，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止。

BFS的过程中以v0为起始点，由近至远，依次访问和v0有路径相通且路径长度为1,2,...的顶点。

为了能够使得这种访问次序得到实现，需要一个队列把访问过的顶点依次保存下来，以便下次依次访问它们的邻接点。(是对应于“先被访问的顶点的邻接点”先于
“后被访问的顶点的邻接点”)。 需要利用 队列 先进先出的特性，可以保持访问的次序。队列为空的时候表明一个连通分量遍历完成。

下面是实现上述广度优先搜索BFS的算法
*/
bool IsEdge(MGraph Graph, Vertex V, Vertex W)
{
    return Graph->G[V][W] < INFINITY ? true: false; //其实主要就是要找到这个点是不是V0的邻接点。
}

/*Visited[]为全局变量，已经初始化为false*/

void BFS(MGraph Graph, Vertex S, void(*Visit)(Vertex))
{
    /*以S为出发点对邻接矩阵存储的图Graph进行BFS搜索*/
    Queue Q;
    Vertex V, W;

    Q = CreatQueue(Maxsize);
    //下面是访问顶点S，此处可根据具体访问的需要进行改写
    Visit(S);
    Visited(S) = true;
    AddQ(Q,S);

    while (!IsEmpty(Q))
    {
        V = DeleteQ(Q); //弹出V
        for (W = 0; W < Graph->NV; W++)
        {
            //若W是V的邻接点并且未访问过
            if (!Visited[W] && IsEdge(Graph, V, W))
            {
                //访问顶点W
                Visit(W);
                Visited[W] = true; //标记W已被访问
                AddQ(Q, W);

            }
            
        }
    
    }
    
}
/*
分析上面的算法，每个顶点至多进一次队列。遍历图的过程实质是通过边或弧找邻接点的过程，因此广度优先搜索的时间复杂度和深度优先搜索相同，两者不同之处
仅仅是对顶点访问的顺序不同。当用邻接矩阵表示图的存储结构时，所需时间是O(|V|^2)。而当以邻接表作为图的存储结构时，找邻接点所需时间为O(|E|).因此，
当以邻接表作存储结构时，广度优先搜索遍历图的时间复杂度为O(|E|+|V|);


*/